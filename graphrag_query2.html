<html>
    <head>
        <meta charset="utf-8">
        
            <script>function neighbourhoodHighlight(params) {
  // console.log("in nieghbourhoodhighlight");
  allNodes = nodes.get({ returnType: "Object" });
  // originalNodes = JSON.parse(JSON.stringify(allNodes));
  // if something is selected:
  if (params.nodes.length > 0) {
    highlightActive = true;
    var i, j;
    var selectedNode = params.nodes[0];
    var degrees = 2;

    // mark all nodes as hard to read.
    for (let nodeId in allNodes) {
      // nodeColors[nodeId] = allNodes[nodeId].color;
      allNodes[nodeId].color = "rgba(200,200,200,0.5)";
      if (allNodes[nodeId].hiddenLabel === undefined) {
        allNodes[nodeId].hiddenLabel = allNodes[nodeId].label;
        allNodes[nodeId].label = undefined;
      }
    }
    var connectedNodes = network.getConnectedNodes(selectedNode);
    var allConnectedNodes = [];

    // get the second degree nodes
    for (i = 1; i < degrees; i++) {
      for (j = 0; j < connectedNodes.length; j++) {
        allConnectedNodes = allConnectedNodes.concat(
          network.getConnectedNodes(connectedNodes[j])
        );
      }
    }

    // all second degree nodes get a different color and their label back
    for (i = 0; i < allConnectedNodes.length; i++) {
      // allNodes[allConnectedNodes[i]].color = "pink";
      allNodes[allConnectedNodes[i]].color = "rgba(150,150,150,0.75)";
      if (allNodes[allConnectedNodes[i]].hiddenLabel !== undefined) {
        allNodes[allConnectedNodes[i]].label =
          allNodes[allConnectedNodes[i]].hiddenLabel;
        allNodes[allConnectedNodes[i]].hiddenLabel = undefined;
      }
    }

    // all first degree nodes get their own color and their label back
    for (i = 0; i < connectedNodes.length; i++) {
      // allNodes[connectedNodes[i]].color = undefined;
      allNodes[connectedNodes[i]].color = nodeColors[connectedNodes[i]];
      if (allNodes[connectedNodes[i]].hiddenLabel !== undefined) {
        allNodes[connectedNodes[i]].label =
          allNodes[connectedNodes[i]].hiddenLabel;
        allNodes[connectedNodes[i]].hiddenLabel = undefined;
      }
    }

    // the main node gets its own color and its label back.
    // allNodes[selectedNode].color = undefined;
    allNodes[selectedNode].color = nodeColors[selectedNode];
    if (allNodes[selectedNode].hiddenLabel !== undefined) {
      allNodes[selectedNode].label = allNodes[selectedNode].hiddenLabel;
      allNodes[selectedNode].hiddenLabel = undefined;
    }
  } else if (highlightActive === true) {
    // console.log("highlightActive was true");
    // reset all nodes
    for (let nodeId in allNodes) {
      // allNodes[nodeId].color = "purple";
      allNodes[nodeId].color = nodeColors[nodeId];
      // delete allNodes[nodeId].color;
      if (allNodes[nodeId].hiddenLabel !== undefined) {
        allNodes[nodeId].label = allNodes[nodeId].hiddenLabel;
        allNodes[nodeId].hiddenLabel = undefined;
      }
    }
    highlightActive = false;
  }

  // transform the object into an array
  var updateArray = [];
  if (params.nodes.length > 0) {
    for (let nodeId in allNodes) {
      if (allNodes.hasOwnProperty(nodeId)) {
        // console.log(allNodes[nodeId]);
        updateArray.push(allNodes[nodeId]);
      }
    }
    nodes.update(updateArray);
  } else {
    // console.log("Nothing was selected");
    for (let nodeId in allNodes) {
      if (allNodes.hasOwnProperty(nodeId)) {
        // console.log(allNodes[nodeId]);
        // allNodes[nodeId].color = {};
        updateArray.push(allNodes[nodeId]);
      }
    }
    nodes.update(updateArray);
  }
}

function filterHighlight(params) {
  allNodes = nodes.get({ returnType: "Object" });
  // if something is selected:
  if (params.nodes.length > 0) {
    filterActive = true;
    let selectedNodes = params.nodes;

    // hiding all nodes and saving the label
    for (let nodeId in allNodes) {
      allNodes[nodeId].hidden = true;
      if (allNodes[nodeId].savedLabel === undefined) {
        allNodes[nodeId].savedLabel = allNodes[nodeId].label;
        allNodes[nodeId].label = undefined;
      }
    }

    for (let i=0; i < selectedNodes.length; i++) {
      allNodes[selectedNodes[i]].hidden = false;
      if (allNodes[selectedNodes[i]].savedLabel !== undefined) {
        allNodes[selectedNodes[i]].label = allNodes[selectedNodes[i]].savedLabel;
        allNodes[selectedNodes[i]].savedLabel = undefined;
      }
    }

  } else if (filterActive === true) {
    // reset all nodes
    for (let nodeId in allNodes) {
      allNodes[nodeId].hidden = false;
      if (allNodes[nodeId].savedLabel !== undefined) {
        allNodes[nodeId].label = allNodes[nodeId].savedLabel;
        allNodes[nodeId].savedLabel = undefined;
      }
    }
    filterActive = false;
  }

  // transform the object into an array
  var updateArray = [];
  if (params.nodes.length > 0) {
    for (let nodeId in allNodes) {
      if (allNodes.hasOwnProperty(nodeId)) {
        updateArray.push(allNodes[nodeId]);
      }
    }
    nodes.update(updateArray);
  } else {
    for (let nodeId in allNodes) {
      if (allNodes.hasOwnProperty(nodeId)) {
        updateArray.push(allNodes[nodeId]);
      }
    }
    nodes.update(updateArray);
  }
}

function selectNode(nodes) {
  network.selectNodes(nodes);
  neighbourhoodHighlight({ nodes: nodes });
  return nodes;
}

function selectNodes(nodes) {
  network.selectNodes(nodes);
  filterHighlight({nodes: nodes});
  return nodes;
}

function highlightFilter(filter) {
  let selectedNodes = []
  let selectedProp = filter['property']
  if (filter['item'] === 'node') {
    let allNodes = nodes.get({ returnType: "Object" });
    for (let nodeId in allNodes) {
      if (allNodes[nodeId][selectedProp] && filter['value'].includes((allNodes[nodeId][selectedProp]).toString())) {
        selectedNodes.push(nodeId)
      }
    }
  }
  else if (filter['item'] === 'edge'){
    let allEdges = edges.get({returnType: 'object'});
    // check if the selected property exists for selected edge and select the nodes connected to the edge
    for (let edge in allEdges) {
      if (allEdges[edge][selectedProp] && filter['value'].includes((allEdges[edge][selectedProp]).toString())) {
        selectedNodes.push(allEdges[edge]['from'])
        selectedNodes.push(allEdges[edge]['to'])
      }
    }
  }
  selectNodes(selectedNodes)
}</script>
            <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.2/dist/dist/vis-network.min.css" integrity="sha512-WgxfT5LWjfszlPHXRmBWHkV2eceiWTOBvrKCNbdgDYTHrT2AeLCGbF4sZlZw3UMN3WtL0tGUoIAKsu8mllg/XA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
            <script src="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.2/dist/vis-network.min.js" integrity="sha512-LnvoEWDFrqGHlHmDD2101OrLcbsfkrzoSpvtSQtxK3RMnRV0eOkhhBN2dXHKRrUU8p2DGRTk35n4O8nWSVe1mQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
            
            
            
            
            
            

        
<center>
<h1></h1>
</center>

<!-- <link rel="stylesheet" href="../node_modules/vis/dist/vis.min.css" type="text/css" />
<script type="text/javascript" src="../node_modules/vis/dist/vis.js"> </script>-->
        <link
          href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css"
          rel="stylesheet"
          integrity="sha384-eOJMYsd53ii+scO/bJGFsiCZc+5NDVN2yr8+0RDqr0Ql0h+rP48ckxlpbzKgwra6"
          crossorigin="anonymous"
        />
        <script
          src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/js/bootstrap.bundle.min.js"
          integrity="sha384-JEW9xMcG8R+pH31jmWH6WWP0WintQrMb4s7ZOdauHnUtxwoG2vI5DkLtS3qm9Ekf"
          crossorigin="anonymous"
        ></script>


        <center>
          <h1></h1>
        </center>
        <style type="text/css">

             #mynetwork {
                 width: 100%;
                 height: 700px;
                 background-color: #1a1a2e;
                 border: 1px solid lightgray;
                 position: relative;
                 float: left;
             }

             

             

             
        </style>
    </head>


    <body>
        <div class="card" style="width: 100%">
            
            
            <div id="mynetwork" class="card-body"></div>
        </div>

        
        

        <script type="text/javascript">

              // initialize global variables.
              var edges;
              var nodes;
              var allNodes;
              var allEdges;
              var nodeColors;
              var originalNodes;
              var network;
              var container;
              var options, data;
              var filter = {
                  item : '',
                  property : '',
                  value : []
              };

              

              

              // This method is responsible for drawing the graph, returns the drawn network
              function drawGraph() {
                  var container = document.getElementById('mynetwork');

                  

                  // parsing and collecting nodes and edges from the python
                  nodes = new vis.DataSet([{"color": "#e74c3c", "font": {"color": "white"}, "id": "query", "label": "Query", "shape": "diamond", "size": 35, "title": "Compare and contrast Gaussian kernels used in different contexts across machine learning and statistical methods."}, {"color": "#3498db", "font": {"color": "white"}, "id": "paper_0000", "label": "paper_0000", "shape": "dot", "size": 25, "title": "[VECTOR] additive models @xcite provide an important family of models for semiparametric regression or classification . some reasons for the success of additive models are their increased flexibility when compared to linear or generalized linear models and their increased interpretability when compared to fully nonparametric models .\nScore: 1.000"}, {"color": "#2ecc71", "font": {"color": "white"}, "id": "paper_0211", "label": "paper_0211", "shape": "dot", "size": 25, "title": "[GRAPH] given competing mathematical models to describe a process , we wish to know whether our data is compatible with the candidate models . often comparing models requires optimization and fitting time course data to estimate parameter values and then applying an information criterion to select a ` best \u0027 model @xcite .\nScore: 0.750"}, {"color": "#3498db", "font": {"color": "white"}, "id": "paper_0101", "label": "paper_0101", "shape": "dot", "size": 25, "title": "[VECTOR] model selection is an important problem in many areas including machine learning .\nScore: 0.476"}, {"color": "#2ecc71", "font": {"color": "white"}, "id": "paper_0208", "label": "paper_0208", "shape": "dot", "size": 25, "title": "[GRAPH] classification problem is one of the most important tasks in time series data mining . a well - known 1-nearest neighbor ( 1-nn ) with dynamic time warping ( dtw )\nScore: 0.330"}, {"color": "#3498db", "font": {"color": "white"}, "id": "paper_0234", "label": "paper_0234", "shape": "dot", "size": 25, "title": "[VECTOR] we consider the following sequence space model @xmath4 where @xmath5 are the coefficients of a signal and the noise @xmath6 has a diagonal covariance matrix @xmath7 .\nScore: 0.200"}, {"color": "#e67e22", "font": {"color": "white"}, "id": "concept_support vector machine", "label": "support vector machine", "shape": "dot", "size": 15, "title": "Concept: support vector machine\nCategory: ml_method"}, {"color": "#e67e22", "font": {"color": "white"}, "id": "concept_rate of convergence", "label": "rate of convergence", "shape": "dot", "size": 15, "title": "Concept: rate of convergence\nCategory: statistical_method"}, {"color": "#e67e22", "font": {"color": "white"}, "id": "concept_gaussian radial basis function kernel", "label": "gaussian radial basis function kernel", "shape": "dot", "size": 15, "title": "Concept: gaussian radial basis function kernel\nCategory: ml_method"}, {"color": "#e67e22", "font": {"color": "white"}, "id": "concept_reproducing kernel hilbert space", "label": "reproducing kernel hilbert space", "shape": "dot", "size": 15, "title": "Concept: reproducing kernel hilbert space\nCategory: math_concept"}, {"color": "#9b59b6", "font": {"color": "white"}, "id": "method_quantile regression", "label": "quantile regression", "shape": "triangle", "size": 15, "title": "Method: quantile regression"}, {"color": "#9b59b6", "font": {"color": "white"}, "id": "method_support vector machine", "label": "support vector machine", "shape": "triangle", "size": 15, "title": "Method: support vector machine"}, {"color": "#9b59b6", "font": {"color": "white"}, "id": "method_regularized kernel method", "label": "regularized kernel method", "shape": "triangle", "size": 15, "title": "Method: regularized kernel method"}, {"color": "#e67e22", "font": {"color": "white"}, "id": "concept_generalizability", "label": "generalizability", "shape": "dot", "size": 15, "title": "Concept: generalizability\nCategory: statistical_method"}, {"color": "#e67e22", "font": {"color": "white"}, "id": "concept_model selection", "label": "model selection", "shape": "dot", "size": 15, "title": "Concept: model selection\nCategory: Statistical_Method"}, {"color": "#e67e22", "font": {"color": "white"}, "id": "concept_regression analysis", "label": "regression analysis", "shape": "dot", "size": 15, "title": "Concept: regression analysis\nCategory: statistical_method"}, {"color": "#e67e22", "font": {"color": "white"}, "id": "concept_underfitting", "label": "underfitting", "shape": "dot", "size": 15, "title": "Concept: underfitting\nCategory: general"}, {"color": "#9b59b6", "font": {"color": "white"}, "id": "method_maximum log marginal likelihood", "label": "maximum log marginal likelihood", "shape": "triangle", "size": 15, "title": "Method: maximum log marginal likelihood"}, {"color": "#9b59b6", "font": {"color": "white"}, "id": "method_bootstrapping", "label": "bootstrapping", "shape": "triangle", "size": 15, "title": "Method: bootstrapping"}, {"color": "#9b59b6", "font": {"color": "white"}, "id": "method_leave one out cross validation", "label": "leave one out cross validation", "shape": "triangle", "size": 15, "title": "Method: leave one out cross validation"}, {"color": "#e67e22", "font": {"color": "white"}, "id": "concept_penalty function", "label": "penalty function", "shape": "dot", "size": 15, "title": "Concept: penalty function\nCategory: Statistical_Method"}, {"color": "#e67e22", "font": {"color": "white"}, "id": "concept_sequence space model", "label": "sequence space model", "shape": "dot", "size": 15, "title": "Concept: sequence space model\nCategory: Statistical_Method"}, {"color": "#e67e22", "font": {"color": "white"}, "id": "concept_sparse parameter vector", "label": "sparse parameter vector", "shape": "dot", "size": 15, "title": "Concept: sparse parameter vector\nCategory: Statistical_Method"}, {"color": "#e67e22", "font": {"color": "white"}, "id": "concept_gaussian noise", "label": "gaussian noise", "shape": "dot", "size": 15, "title": "Concept: gaussian noise\nCategory: Statistical_Method"}, {"color": "#9b59b6", "font": {"color": "white"}, "id": "method_aic criterion", "label": "aic criterion", "shape": "triangle", "size": 15, "title": "Method: aic criterion"}, {"color": "#9b59b6", "font": {"color": "white"}, "id": "method_penalty-based model selection", "label": "penalty-based model selection", "shape": "triangle", "size": 15, "title": "Method: penalty-based model selection"}, {"color": "#9b59b6", "font": {"color": "white"}, "id": "method_simulation study", "label": "simulation study", "shape": "triangle", "size": 15, "title": "Method: simulation study"}, {"color": "#e67e22", "font": {"color": "white"}, "id": "concept_overfitting", "label": "overfitting", "shape": "dot", "size": 15, "title": "Shared: overfitting"}]);
                  edges = new vis.DataSet([{"color": "#3498db", "from": "query", "title": "hybrid search", "to": "paper_0000", "width": 2}, {"color": "#3498db", "from": "query", "title": "hybrid search", "to": "paper_0101", "width": 2}, {"color": "#3498db", "from": "query", "title": "hybrid search", "to": "paper_0234", "width": 2}, {"color": "#e67e2288", "from": "paper_0000", "title": "MENTIONS_CONCEPT", "to": "concept_support vector machine", "width": 1}, {"color": "#e67e2288", "from": "paper_0000", "title": "MENTIONS_CONCEPT", "to": "concept_rate of convergence", "width": 1}, {"color": "#e67e2288", "from": "paper_0000", "title": "MENTIONS_CONCEPT", "to": "concept_gaussian radial basis function kernel", "width": 1}, {"color": "#e67e2288", "from": "paper_0000", "title": "MENTIONS_CONCEPT", "to": "concept_reproducing kernel hilbert space", "width": 1}, {"color": "#9b59b688", "from": "paper_0000", "title": "USES_METHOD", "to": "method_quantile regression", "width": 1}, {"color": "#9b59b688", "from": "paper_0000", "title": "USES_METHOD", "to": "method_support vector machine", "width": 1}, {"color": "#9b59b688", "from": "paper_0000", "title": "USES_METHOD", "to": "method_regularized kernel method", "width": 1}, {"color": "#e67e2288", "from": "paper_0101", "title": "MENTIONS_CONCEPT", "to": "concept_generalizability", "width": 1}, {"color": "#e67e2288", "from": "paper_0101", "title": "MENTIONS_CONCEPT", "to": "concept_model selection", "width": 1}, {"color": "#e67e2288", "from": "paper_0101", "title": "MENTIONS_CONCEPT", "to": "concept_regression analysis", "width": 1}, {"color": "#e67e2288", "from": "paper_0101", "title": "MENTIONS_CONCEPT", "to": "concept_underfitting", "width": 1}, {"color": "#9b59b688", "from": "paper_0101", "title": "USES_METHOD", "to": "method_maximum log marginal likelihood", "width": 1}, {"color": "#9b59b688", "from": "paper_0101", "title": "USES_METHOD", "to": "method_bootstrapping", "width": 1}, {"color": "#9b59b688", "from": "paper_0101", "title": "USES_METHOD", "to": "method_leave one out cross validation", "width": 1}, {"color": "#e67e2288", "from": "paper_0234", "title": "MENTIONS_CONCEPT", "to": "concept_penalty function", "width": 1}, {"color": "#e67e2288", "from": "paper_0234", "title": "MENTIONS_CONCEPT", "to": "concept_sequence space model", "width": 1}, {"color": "#e67e2288", "from": "paper_0234", "title": "MENTIONS_CONCEPT", "to": "concept_sparse parameter vector", "width": 1}, {"color": "#e67e2288", "from": "paper_0234", "title": "MENTIONS_CONCEPT", "to": "concept_gaussian noise", "width": 1}, {"color": "#9b59b688", "from": "paper_0234", "title": "USES_METHOD", "to": "method_aic criterion", "width": 1}, {"color": "#9b59b688", "from": "paper_0234", "title": "USES_METHOD", "to": "method_penalty-based model selection", "width": 1}, {"color": "#9b59b688", "from": "paper_0234", "title": "USES_METHOD", "to": "method_simulation study", "width": 1}, {"color": "#2ecc71", "dashes": true, "from": "concept_model selection", "title": "graph discovery via concept", "to": "paper_0211", "width": 2}, {"color": "#2ecc71", "dashes": true, "from": "concept_overfitting", "title": "graph discovery via concept", "to": "paper_0208", "width": 2}]);

                  nodeColors = {};
                  allNodes = nodes.get({ returnType: "Object" });
                  for (nodeId in allNodes) {
                    nodeColors[nodeId] = allNodes[nodeId].color;
                  }
                  allEdges = edges.get({ returnType: "Object" });
                  // adding nodes and edges to the graph
                  data = {nodes: nodes, edges: edges};

                  var options = {"physics": {"forceAtlas2Based": {"gravitationalConstant": -100, "centralGravity": 0.01, "springLength": 200, "springConstant": 0.05}, "solver": "forceAtlas2Based", "stabilization": {"iterations": 150}}, "nodes": {"font": {"size": 14, "face": "Arial"}}, "edges": {"smooth": {"type": "continuous"}, "font": {"size": 10, "align": "middle"}}};

                  


                  

                  network = new vis.Network(container, data, options);

                  

                  

                  


                  

                  return network;

              }
              drawGraph();
        </script>
    </body>
</html>